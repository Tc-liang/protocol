// Copyright © 2023 OpenIM. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.1
// source: msg/msg.proto

package msg

import (
	context "context"
	sdkws "github.com/openimsdk/protocol/sdkws"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	IMMsgService_GetMaxSeq_FullMethodName                        = "/openim.msg.IMMsgService/GetMaxSeq"
	IMMsgService_GetMaxSeqs_FullMethodName                       = "/openim.msg.IMMsgService/GetMaxSeqs"
	IMMsgService_GetHasReadSeqs_FullMethodName                   = "/openim.msg.IMMsgService/GetHasReadSeqs"
	IMMsgService_GetMsgByConversationIDs_FullMethodName          = "/openim.msg.IMMsgService/GetMsgByConversationIDs"
	IMMsgService_GetConversationMaxSeq_FullMethodName            = "/openim.msg.IMMsgService/GetConversationMaxSeq"
	IMMsgService_PullMessageBySeqs_FullMethodName                = "/openim.msg.IMMsgService/PullMessageBySeqs"
	IMMsgService_GetSeqMessage_FullMethodName                    = "/openim.msg.IMMsgService/GetSeqMessage"
	IMMsgService_SearchMessage_FullMethodName                    = "/openim.msg.IMMsgService/SearchMessage"
	IMMsgService_SendMsg_FullMethodName                          = "/openim.msg.IMMsgService/SendMsg"
	IMMsgService_SendSimpleMsg_FullMethodName                    = "/openim.msg.IMMsgService/SendSimpleMsg"
	IMMsgService_SetUserConversationsMinSeq_FullMethodName       = "/openim.msg.IMMsgService/SetUserConversationsMinSeq"
	IMMsgService_ClearConversationsMsg_FullMethodName            = "/openim.msg.IMMsgService/ClearConversationsMsg"
	IMMsgService_UserClearAllMsg_FullMethodName                  = "/openim.msg.IMMsgService/UserClearAllMsg"
	IMMsgService_DeleteMsgs_FullMethodName                       = "/openim.msg.IMMsgService/DeleteMsgs"
	IMMsgService_DeleteMsgPhysicalBySeq_FullMethodName           = "/openim.msg.IMMsgService/DeleteMsgPhysicalBySeq"
	IMMsgService_DeleteMsgPhysical_FullMethodName                = "/openim.msg.IMMsgService/DeleteMsgPhysical"
	IMMsgService_SetSendMsgStatus_FullMethodName                 = "/openim.msg.IMMsgService/SetSendMsgStatus"
	IMMsgService_GetSendMsgStatus_FullMethodName                 = "/openim.msg.IMMsgService/GetSendMsgStatus"
	IMMsgService_RevokeMsg_FullMethodName                        = "/openim.msg.IMMsgService/RevokeMsg"
	IMMsgService_MarkMsgsAsRead_FullMethodName                   = "/openim.msg.IMMsgService/MarkMsgsAsRead"
	IMMsgService_MarkConversationAsRead_FullMethodName           = "/openim.msg.IMMsgService/MarkConversationAsRead"
	IMMsgService_RPCMarkConversationAsRead_FullMethodName        = "/openim.msg.IMMsgService/RPCMarkConversationAsRead"
	IMMsgService_BotMarkMaxMsgAsRead_FullMethodName              = "/openim.msg.IMMsgService/BotMarkMaxMsgAsRead"
	IMMsgService_SetConversationHasReadSeq_FullMethodName        = "/openim.msg.IMMsgService/SetConversationHasReadSeq"
	IMMsgService_GetConversationsHasReadAndMaxSeq_FullMethodName = "/openim.msg.IMMsgService/GetConversationsHasReadAndMaxSeq"
	IMMsgService_GetActiveUser_FullMethodName                    = "/openim.msg.IMMsgService/GetActiveUser"
	IMMsgService_GetActiveGroup_FullMethodName                   = "/openim.msg.IMMsgService/GetActiveGroup"
	IMMsgService_GetServerTime_FullMethodName                    = "/openim.msg.IMMsgService/GetServerTime"
	IMMsgService_ClearMsg_FullMethodName                         = "/openim.msg.IMMsgService/ClearMsg"
	IMMsgService_DestructMsgs_FullMethodName                     = "/openim.msg.IMMsgService/DestructMsgs"
	IMMsgService_GetActiveConversation_FullMethodName            = "/openim.msg.IMMsgService/GetActiveConversation"
	IMMsgService_SetUserConversationMaxSeq_FullMethodName        = "/openim.msg.IMMsgService/SetUserConversationMaxSeq"
	IMMsgService_SetUserConversationMinSeq_FullMethodName        = "/openim.msg.IMMsgService/SetUserConversationMinSeq"
	IMMsgService_GetLastMessageSeqByTime_FullMethodName          = "/openim.msg.IMMsgService/GetLastMessageSeqByTime"
	IMMsgService_GetLastMessage_FullMethodName                   = "/openim.msg.IMMsgService/GetLastMessage"
	IMMsgService_AddEmoji_FullMethodName                         = "/openim.msg.IMMsgService/AddEmoji"
	IMMsgService_RevokeEmoji_FullMethodName                      = "/openim.msg.IMMsgService/RevokeEmoji"
	IMMsgService_BotReadMsgsNotification_FullMethodName          = "/openim.msg.IMMsgService/BotReadMsgsNotification"
	IMMsgService_AIStreamMsgNotification_FullMethodName          = "/openim.msg.IMMsgService/AIStreamMsgNotification"
)

// IMMsgServiceClient is the client API for IMMsgService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IMMsgServiceClient interface {
	// 获取最小最大seq（包括用户的，以及指定群组的）
	GetMaxSeq(ctx context.Context, in *sdkws.GetMaxSeqReq, opts ...grpc.CallOption) (*sdkws.GetMaxSeqResp, error)
	// 获取会话列表的最大seq
	GetMaxSeqs(ctx context.Context, in *GetMaxSeqsReq, opts ...grpc.CallOption) (*SeqsInfoResp, error)
	// 获取会话列表已读的最大seq
	GetHasReadSeqs(ctx context.Context, in *GetHasReadSeqsReq, opts ...grpc.CallOption) (*SeqsInfoResp, error)
	// 获取最新消息
	GetMsgByConversationIDs(ctx context.Context, in *GetMsgByConversationIDsReq, opts ...grpc.CallOption) (*GetMsgByConversationIDsResp, error)
	GetConversationMaxSeq(ctx context.Context, in *GetConversationMaxSeqReq, opts ...grpc.CallOption) (*GetConversationMaxSeqResp, error)
	// 拉取历史消息（包括用户的，以及指定群组的）
	PullMessageBySeqs(ctx context.Context, in *sdkws.PullMessageBySeqsReq, opts ...grpc.CallOption) (*sdkws.PullMessageBySeqsResp, error)
	GetSeqMessage(ctx context.Context, in *GetSeqMessageReq, opts ...grpc.CallOption) (*GetSeqMessageResp, error)
	SearchMessage(ctx context.Context, in *SearchMessageReq, opts ...grpc.CallOption) (*SearchMessageResp, error)
	// 发送消息
	SendMsg(ctx context.Context, in *SendMsgReq, opts ...grpc.CallOption) (*SendMsgResp, error)
	// 简易发送消息
	SendSimpleMsg(ctx context.Context, in *SendSimpleMsgReq, opts ...grpc.CallOption) (*SendSimpleMsgResp, error)
	SetUserConversationsMinSeq(ctx context.Context, in *SetUserConversationsMinSeqReq, opts ...grpc.CallOption) (*SetUserConversationsMinSeqResp, error)
	// 全量清空指定会话消息 重置min seq 比最大seq大1
	ClearConversationsMsg(ctx context.Context, in *ClearConversationsMsgReq, opts ...grpc.CallOption) (*ClearConversationsMsgResp, error)
	// 删除用户全部消息 重置min seq 比最大seq大1
	UserClearAllMsg(ctx context.Context, in *UserClearAllMsgReq, opts ...grpc.CallOption) (*UserClearAllMsgResp, error)
	// 用户标记删除部分消息by Seq
	DeleteMsgs(ctx context.Context, in *DeleteMsgsReq, opts ...grpc.CallOption) (*DeleteMsgsResp, error)
	// seq物理删除消息
	DeleteMsgPhysicalBySeq(ctx context.Context, in *DeleteMsgPhysicalBySeqReq, opts ...grpc.CallOption) (*DeleteMsgPhysicalBySeqResp, error)
	// 物理删除消息by 时间
	DeleteMsgPhysical(ctx context.Context, in *DeleteMsgPhysicalReq, opts ...grpc.CallOption) (*DeleteMsgPhysicalResp, error)
	// 设置消息是否发送成功-针对api发送的消息
	SetSendMsgStatus(ctx context.Context, in *SetSendMsgStatusReq, opts ...grpc.CallOption) (*SetSendMsgStatusResp, error)
	// 获取消息发送状态
	GetSendMsgStatus(ctx context.Context, in *GetSendMsgStatusReq, opts ...grpc.CallOption) (*GetSendMsgStatusResp, error)
	RevokeMsg(ctx context.Context, in *RevokeMsgReq, opts ...grpc.CallOption) (*RevokeMsgResp, error)
	// mark as read
	MarkMsgsAsRead(ctx context.Context, in *MarkMsgsAsReadReq, opts ...grpc.CallOption) (*MarkMsgsAsReadResp, error)
	MarkConversationAsRead(ctx context.Context, in *MarkConversationAsReadReq, opts ...grpc.CallOption) (*MarkConversationAsReadResp, error)
	RPCMarkConversationAsRead(ctx context.Context, in *RPCMarkConversationAsReadReq, opts ...grpc.CallOption) (*RPCMarkConversationAsReadResp, error)
	BotMarkMaxMsgAsRead(ctx context.Context, in *BotMarkMaxMsgAsReadReq, opts ...grpc.CallOption) (*BotMarkMaxMsgAsReadResp, error)
	SetConversationHasReadSeq(ctx context.Context, in *SetConversationHasReadSeqReq, opts ...grpc.CallOption) (*SetConversationHasReadSeqResp, error)
	GetConversationsHasReadAndMaxSeq(ctx context.Context, in *GetConversationsHasReadAndMaxSeqReq, opts ...grpc.CallOption) (*GetConversationsHasReadAndMaxSeqResp, error)
	GetActiveUser(ctx context.Context, in *GetActiveUserReq, opts ...grpc.CallOption) (*GetActiveUserResp, error)
	GetActiveGroup(ctx context.Context, in *GetActiveGroupReq, opts ...grpc.CallOption) (*GetActiveGroupResp, error)
	GetServerTime(ctx context.Context, in *GetServerTimeReq, opts ...grpc.CallOption) (*GetServerTimeResp, error)
	ClearMsg(ctx context.Context, in *ClearMsgReq, opts ...grpc.CallOption) (*ClearMsgResp, error)
	DestructMsgs(ctx context.Context, in *DestructMsgsReq, opts ...grpc.CallOption) (*DestructMsgsResp, error)
	GetActiveConversation(ctx context.Context, in *GetActiveConversationReq, opts ...grpc.CallOption) (*GetActiveConversationResp, error)
	SetUserConversationMaxSeq(ctx context.Context, in *SetUserConversationMaxSeqReq, opts ...grpc.CallOption) (*SetUserConversationMaxSeqResp, error)
	SetUserConversationMinSeq(ctx context.Context, in *SetUserConversationMinSeqReq, opts ...grpc.CallOption) (*SetUserConversationMinSeqResp, error)
	GetLastMessageSeqByTime(ctx context.Context, in *GetLastMessageSeqByTimeReq, opts ...grpc.CallOption) (*GetLastMessageSeqByTimeResp, error)
	GetLastMessage(ctx context.Context, in *GetLastMessageReq, opts ...grpc.CallOption) (*GetLastMessageResp, error)
	AddEmoji(ctx context.Context, in *AddEmojiReq, opts ...grpc.CallOption) (*AddEmojiResp, error)
	RevokeEmoji(ctx context.Context, in *RevokeEmojiReq, opts ...grpc.CallOption) (*RevokeEmojiResp, error)
	BotReadMsgsNotification(ctx context.Context, in *BotReadMsgsNotificationReq, opts ...grpc.CallOption) (*BotReadMsgsNotificationResp, error)
	AIStreamMsgNotification(ctx context.Context, in *AIStreamNotificationReq, opts ...grpc.CallOption) (*AIStreamNotificationResp, error)
}

type iMMsgServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIMMsgServiceClient(cc grpc.ClientConnInterface) IMMsgServiceClient {
	return &iMMsgServiceClient{cc}
}

func (c *iMMsgServiceClient) GetMaxSeq(ctx context.Context, in *sdkws.GetMaxSeqReq, opts ...grpc.CallOption) (*sdkws.GetMaxSeqResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(sdkws.GetMaxSeqResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetMaxSeq_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetMaxSeqs(ctx context.Context, in *GetMaxSeqsReq, opts ...grpc.CallOption) (*SeqsInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SeqsInfoResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetMaxSeqs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetHasReadSeqs(ctx context.Context, in *GetHasReadSeqsReq, opts ...grpc.CallOption) (*SeqsInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SeqsInfoResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetHasReadSeqs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetMsgByConversationIDs(ctx context.Context, in *GetMsgByConversationIDsReq, opts ...grpc.CallOption) (*GetMsgByConversationIDsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMsgByConversationIDsResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetMsgByConversationIDs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetConversationMaxSeq(ctx context.Context, in *GetConversationMaxSeqReq, opts ...grpc.CallOption) (*GetConversationMaxSeqResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConversationMaxSeqResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetConversationMaxSeq_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) PullMessageBySeqs(ctx context.Context, in *sdkws.PullMessageBySeqsReq, opts ...grpc.CallOption) (*sdkws.PullMessageBySeqsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(sdkws.PullMessageBySeqsResp)
	err := c.cc.Invoke(ctx, IMMsgService_PullMessageBySeqs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetSeqMessage(ctx context.Context, in *GetSeqMessageReq, opts ...grpc.CallOption) (*GetSeqMessageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSeqMessageResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetSeqMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) SearchMessage(ctx context.Context, in *SearchMessageReq, opts ...grpc.CallOption) (*SearchMessageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchMessageResp)
	err := c.cc.Invoke(ctx, IMMsgService_SearchMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) SendMsg(ctx context.Context, in *SendMsgReq, opts ...grpc.CallOption) (*SendMsgResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendMsgResp)
	err := c.cc.Invoke(ctx, IMMsgService_SendMsg_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) SendSimpleMsg(ctx context.Context, in *SendSimpleMsgReq, opts ...grpc.CallOption) (*SendSimpleMsgResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendSimpleMsgResp)
	err := c.cc.Invoke(ctx, IMMsgService_SendSimpleMsg_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) SetUserConversationsMinSeq(ctx context.Context, in *SetUserConversationsMinSeqReq, opts ...grpc.CallOption) (*SetUserConversationsMinSeqResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUserConversationsMinSeqResp)
	err := c.cc.Invoke(ctx, IMMsgService_SetUserConversationsMinSeq_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) ClearConversationsMsg(ctx context.Context, in *ClearConversationsMsgReq, opts ...grpc.CallOption) (*ClearConversationsMsgResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearConversationsMsgResp)
	err := c.cc.Invoke(ctx, IMMsgService_ClearConversationsMsg_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) UserClearAllMsg(ctx context.Context, in *UserClearAllMsgReq, opts ...grpc.CallOption) (*UserClearAllMsgResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserClearAllMsgResp)
	err := c.cc.Invoke(ctx, IMMsgService_UserClearAllMsg_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) DeleteMsgs(ctx context.Context, in *DeleteMsgsReq, opts ...grpc.CallOption) (*DeleteMsgsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMsgsResp)
	err := c.cc.Invoke(ctx, IMMsgService_DeleteMsgs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) DeleteMsgPhysicalBySeq(ctx context.Context, in *DeleteMsgPhysicalBySeqReq, opts ...grpc.CallOption) (*DeleteMsgPhysicalBySeqResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMsgPhysicalBySeqResp)
	err := c.cc.Invoke(ctx, IMMsgService_DeleteMsgPhysicalBySeq_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) DeleteMsgPhysical(ctx context.Context, in *DeleteMsgPhysicalReq, opts ...grpc.CallOption) (*DeleteMsgPhysicalResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMsgPhysicalResp)
	err := c.cc.Invoke(ctx, IMMsgService_DeleteMsgPhysical_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) SetSendMsgStatus(ctx context.Context, in *SetSendMsgStatusReq, opts ...grpc.CallOption) (*SetSendMsgStatusResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetSendMsgStatusResp)
	err := c.cc.Invoke(ctx, IMMsgService_SetSendMsgStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetSendMsgStatus(ctx context.Context, in *GetSendMsgStatusReq, opts ...grpc.CallOption) (*GetSendMsgStatusResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSendMsgStatusResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetSendMsgStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) RevokeMsg(ctx context.Context, in *RevokeMsgReq, opts ...grpc.CallOption) (*RevokeMsgResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeMsgResp)
	err := c.cc.Invoke(ctx, IMMsgService_RevokeMsg_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) MarkMsgsAsRead(ctx context.Context, in *MarkMsgsAsReadReq, opts ...grpc.CallOption) (*MarkMsgsAsReadResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkMsgsAsReadResp)
	err := c.cc.Invoke(ctx, IMMsgService_MarkMsgsAsRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) MarkConversationAsRead(ctx context.Context, in *MarkConversationAsReadReq, opts ...grpc.CallOption) (*MarkConversationAsReadResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkConversationAsReadResp)
	err := c.cc.Invoke(ctx, IMMsgService_MarkConversationAsRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) RPCMarkConversationAsRead(ctx context.Context, in *RPCMarkConversationAsReadReq, opts ...grpc.CallOption) (*RPCMarkConversationAsReadResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RPCMarkConversationAsReadResp)
	err := c.cc.Invoke(ctx, IMMsgService_RPCMarkConversationAsRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) BotMarkMaxMsgAsRead(ctx context.Context, in *BotMarkMaxMsgAsReadReq, opts ...grpc.CallOption) (*BotMarkMaxMsgAsReadResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BotMarkMaxMsgAsReadResp)
	err := c.cc.Invoke(ctx, IMMsgService_BotMarkMaxMsgAsRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) SetConversationHasReadSeq(ctx context.Context, in *SetConversationHasReadSeqReq, opts ...grpc.CallOption) (*SetConversationHasReadSeqResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetConversationHasReadSeqResp)
	err := c.cc.Invoke(ctx, IMMsgService_SetConversationHasReadSeq_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetConversationsHasReadAndMaxSeq(ctx context.Context, in *GetConversationsHasReadAndMaxSeqReq, opts ...grpc.CallOption) (*GetConversationsHasReadAndMaxSeqResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConversationsHasReadAndMaxSeqResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetConversationsHasReadAndMaxSeq_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetActiveUser(ctx context.Context, in *GetActiveUserReq, opts ...grpc.CallOption) (*GetActiveUserResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveUserResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetActiveUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetActiveGroup(ctx context.Context, in *GetActiveGroupReq, opts ...grpc.CallOption) (*GetActiveGroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveGroupResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetActiveGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetServerTime(ctx context.Context, in *GetServerTimeReq, opts ...grpc.CallOption) (*GetServerTimeResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetServerTimeResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetServerTime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) ClearMsg(ctx context.Context, in *ClearMsgReq, opts ...grpc.CallOption) (*ClearMsgResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearMsgResp)
	err := c.cc.Invoke(ctx, IMMsgService_ClearMsg_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) DestructMsgs(ctx context.Context, in *DestructMsgsReq, opts ...grpc.CallOption) (*DestructMsgsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DestructMsgsResp)
	err := c.cc.Invoke(ctx, IMMsgService_DestructMsgs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetActiveConversation(ctx context.Context, in *GetActiveConversationReq, opts ...grpc.CallOption) (*GetActiveConversationResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveConversationResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetActiveConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) SetUserConversationMaxSeq(ctx context.Context, in *SetUserConversationMaxSeqReq, opts ...grpc.CallOption) (*SetUserConversationMaxSeqResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUserConversationMaxSeqResp)
	err := c.cc.Invoke(ctx, IMMsgService_SetUserConversationMaxSeq_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) SetUserConversationMinSeq(ctx context.Context, in *SetUserConversationMinSeqReq, opts ...grpc.CallOption) (*SetUserConversationMinSeqResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUserConversationMinSeqResp)
	err := c.cc.Invoke(ctx, IMMsgService_SetUserConversationMinSeq_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetLastMessageSeqByTime(ctx context.Context, in *GetLastMessageSeqByTimeReq, opts ...grpc.CallOption) (*GetLastMessageSeqByTimeResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLastMessageSeqByTimeResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetLastMessageSeqByTime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) GetLastMessage(ctx context.Context, in *GetLastMessageReq, opts ...grpc.CallOption) (*GetLastMessageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLastMessageResp)
	err := c.cc.Invoke(ctx, IMMsgService_GetLastMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) AddEmoji(ctx context.Context, in *AddEmojiReq, opts ...grpc.CallOption) (*AddEmojiResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddEmojiResp)
	err := c.cc.Invoke(ctx, IMMsgService_AddEmoji_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) RevokeEmoji(ctx context.Context, in *RevokeEmojiReq, opts ...grpc.CallOption) (*RevokeEmojiResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeEmojiResp)
	err := c.cc.Invoke(ctx, IMMsgService_RevokeEmoji_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) BotReadMsgsNotification(ctx context.Context, in *BotReadMsgsNotificationReq, opts ...grpc.CallOption) (*BotReadMsgsNotificationResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BotReadMsgsNotificationResp)
	err := c.cc.Invoke(ctx, IMMsgService_BotReadMsgsNotification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iMMsgServiceClient) AIStreamMsgNotification(ctx context.Context, in *AIStreamNotificationReq, opts ...grpc.CallOption) (*AIStreamNotificationResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AIStreamNotificationResp)
	err := c.cc.Invoke(ctx, IMMsgService_AIStreamMsgNotification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IMMsgServiceServer is the server API for IMMsgService service.
// All implementations must embed UnimplementedIMMsgServiceServer
// for forward compatibility.
type IMMsgServiceServer interface {
	// 获取最小最大seq（包括用户的，以及指定群组的）
	GetMaxSeq(context.Context, *sdkws.GetMaxSeqReq) (*sdkws.GetMaxSeqResp, error)
	// 获取会话列表的最大seq
	GetMaxSeqs(context.Context, *GetMaxSeqsReq) (*SeqsInfoResp, error)
	// 获取会话列表已读的最大seq
	GetHasReadSeqs(context.Context, *GetHasReadSeqsReq) (*SeqsInfoResp, error)
	// 获取最新消息
	GetMsgByConversationIDs(context.Context, *GetMsgByConversationIDsReq) (*GetMsgByConversationIDsResp, error)
	GetConversationMaxSeq(context.Context, *GetConversationMaxSeqReq) (*GetConversationMaxSeqResp, error)
	// 拉取历史消息（包括用户的，以及指定群组的）
	PullMessageBySeqs(context.Context, *sdkws.PullMessageBySeqsReq) (*sdkws.PullMessageBySeqsResp, error)
	GetSeqMessage(context.Context, *GetSeqMessageReq) (*GetSeqMessageResp, error)
	SearchMessage(context.Context, *SearchMessageReq) (*SearchMessageResp, error)
	// 发送消息
	SendMsg(context.Context, *SendMsgReq) (*SendMsgResp, error)
	// 简易发送消息
	SendSimpleMsg(context.Context, *SendSimpleMsgReq) (*SendSimpleMsgResp, error)
	SetUserConversationsMinSeq(context.Context, *SetUserConversationsMinSeqReq) (*SetUserConversationsMinSeqResp, error)
	// 全量清空指定会话消息 重置min seq 比最大seq大1
	ClearConversationsMsg(context.Context, *ClearConversationsMsgReq) (*ClearConversationsMsgResp, error)
	// 删除用户全部消息 重置min seq 比最大seq大1
	UserClearAllMsg(context.Context, *UserClearAllMsgReq) (*UserClearAllMsgResp, error)
	// 用户标记删除部分消息by Seq
	DeleteMsgs(context.Context, *DeleteMsgsReq) (*DeleteMsgsResp, error)
	// seq物理删除消息
	DeleteMsgPhysicalBySeq(context.Context, *DeleteMsgPhysicalBySeqReq) (*DeleteMsgPhysicalBySeqResp, error)
	// 物理删除消息by 时间
	DeleteMsgPhysical(context.Context, *DeleteMsgPhysicalReq) (*DeleteMsgPhysicalResp, error)
	// 设置消息是否发送成功-针对api发送的消息
	SetSendMsgStatus(context.Context, *SetSendMsgStatusReq) (*SetSendMsgStatusResp, error)
	// 获取消息发送状态
	GetSendMsgStatus(context.Context, *GetSendMsgStatusReq) (*GetSendMsgStatusResp, error)
	RevokeMsg(context.Context, *RevokeMsgReq) (*RevokeMsgResp, error)
	// mark as read
	MarkMsgsAsRead(context.Context, *MarkMsgsAsReadReq) (*MarkMsgsAsReadResp, error)
	MarkConversationAsRead(context.Context, *MarkConversationAsReadReq) (*MarkConversationAsReadResp, error)
	RPCMarkConversationAsRead(context.Context, *RPCMarkConversationAsReadReq) (*RPCMarkConversationAsReadResp, error)
	BotMarkMaxMsgAsRead(context.Context, *BotMarkMaxMsgAsReadReq) (*BotMarkMaxMsgAsReadResp, error)
	SetConversationHasReadSeq(context.Context, *SetConversationHasReadSeqReq) (*SetConversationHasReadSeqResp, error)
	GetConversationsHasReadAndMaxSeq(context.Context, *GetConversationsHasReadAndMaxSeqReq) (*GetConversationsHasReadAndMaxSeqResp, error)
	GetActiveUser(context.Context, *GetActiveUserReq) (*GetActiveUserResp, error)
	GetActiveGroup(context.Context, *GetActiveGroupReq) (*GetActiveGroupResp, error)
	GetServerTime(context.Context, *GetServerTimeReq) (*GetServerTimeResp, error)
	ClearMsg(context.Context, *ClearMsgReq) (*ClearMsgResp, error)
	DestructMsgs(context.Context, *DestructMsgsReq) (*DestructMsgsResp, error)
	GetActiveConversation(context.Context, *GetActiveConversationReq) (*GetActiveConversationResp, error)
	SetUserConversationMaxSeq(context.Context, *SetUserConversationMaxSeqReq) (*SetUserConversationMaxSeqResp, error)
	SetUserConversationMinSeq(context.Context, *SetUserConversationMinSeqReq) (*SetUserConversationMinSeqResp, error)
	GetLastMessageSeqByTime(context.Context, *GetLastMessageSeqByTimeReq) (*GetLastMessageSeqByTimeResp, error)
	GetLastMessage(context.Context, *GetLastMessageReq) (*GetLastMessageResp, error)
	AddEmoji(context.Context, *AddEmojiReq) (*AddEmojiResp, error)
	RevokeEmoji(context.Context, *RevokeEmojiReq) (*RevokeEmojiResp, error)
	BotReadMsgsNotification(context.Context, *BotReadMsgsNotificationReq) (*BotReadMsgsNotificationResp, error)
	AIStreamMsgNotification(context.Context, *AIStreamNotificationReq) (*AIStreamNotificationResp, error)
	mustEmbedUnimplementedIMMsgServiceServer()
}

// UnimplementedIMMsgServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedIMMsgServiceServer struct{}

func (UnimplementedIMMsgServiceServer) GetMaxSeq(context.Context, *sdkws.GetMaxSeqReq) (*sdkws.GetMaxSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMaxSeq not implemented")
}
func (UnimplementedIMMsgServiceServer) GetMaxSeqs(context.Context, *GetMaxSeqsReq) (*SeqsInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMaxSeqs not implemented")
}
func (UnimplementedIMMsgServiceServer) GetHasReadSeqs(context.Context, *GetHasReadSeqsReq) (*SeqsInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHasReadSeqs not implemented")
}
func (UnimplementedIMMsgServiceServer) GetMsgByConversationIDs(context.Context, *GetMsgByConversationIDsReq) (*GetMsgByConversationIDsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMsgByConversationIDs not implemented")
}
func (UnimplementedIMMsgServiceServer) GetConversationMaxSeq(context.Context, *GetConversationMaxSeqReq) (*GetConversationMaxSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConversationMaxSeq not implemented")
}
func (UnimplementedIMMsgServiceServer) PullMessageBySeqs(context.Context, *sdkws.PullMessageBySeqsReq) (*sdkws.PullMessageBySeqsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullMessageBySeqs not implemented")
}
func (UnimplementedIMMsgServiceServer) GetSeqMessage(context.Context, *GetSeqMessageReq) (*GetSeqMessageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSeqMessage not implemented")
}
func (UnimplementedIMMsgServiceServer) SearchMessage(context.Context, *SearchMessageReq) (*SearchMessageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchMessage not implemented")
}
func (UnimplementedIMMsgServiceServer) SendMsg(context.Context, *SendMsgReq) (*SendMsgResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMsg not implemented")
}
func (UnimplementedIMMsgServiceServer) SendSimpleMsg(context.Context, *SendSimpleMsgReq) (*SendSimpleMsgResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendSimpleMsg not implemented")
}
func (UnimplementedIMMsgServiceServer) SetUserConversationsMinSeq(context.Context, *SetUserConversationsMinSeqReq) (*SetUserConversationsMinSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUserConversationsMinSeq not implemented")
}
func (UnimplementedIMMsgServiceServer) ClearConversationsMsg(context.Context, *ClearConversationsMsgReq) (*ClearConversationsMsgResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearConversationsMsg not implemented")
}
func (UnimplementedIMMsgServiceServer) UserClearAllMsg(context.Context, *UserClearAllMsgReq) (*UserClearAllMsgResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserClearAllMsg not implemented")
}
func (UnimplementedIMMsgServiceServer) DeleteMsgs(context.Context, *DeleteMsgsReq) (*DeleteMsgsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMsgs not implemented")
}
func (UnimplementedIMMsgServiceServer) DeleteMsgPhysicalBySeq(context.Context, *DeleteMsgPhysicalBySeqReq) (*DeleteMsgPhysicalBySeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMsgPhysicalBySeq not implemented")
}
func (UnimplementedIMMsgServiceServer) DeleteMsgPhysical(context.Context, *DeleteMsgPhysicalReq) (*DeleteMsgPhysicalResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMsgPhysical not implemented")
}
func (UnimplementedIMMsgServiceServer) SetSendMsgStatus(context.Context, *SetSendMsgStatusReq) (*SetSendMsgStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSendMsgStatus not implemented")
}
func (UnimplementedIMMsgServiceServer) GetSendMsgStatus(context.Context, *GetSendMsgStatusReq) (*GetSendMsgStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSendMsgStatus not implemented")
}
func (UnimplementedIMMsgServiceServer) RevokeMsg(context.Context, *RevokeMsgReq) (*RevokeMsgResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeMsg not implemented")
}
func (UnimplementedIMMsgServiceServer) MarkMsgsAsRead(context.Context, *MarkMsgsAsReadReq) (*MarkMsgsAsReadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkMsgsAsRead not implemented")
}
func (UnimplementedIMMsgServiceServer) MarkConversationAsRead(context.Context, *MarkConversationAsReadReq) (*MarkConversationAsReadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkConversationAsRead not implemented")
}
func (UnimplementedIMMsgServiceServer) RPCMarkConversationAsRead(context.Context, *RPCMarkConversationAsReadReq) (*RPCMarkConversationAsReadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RPCMarkConversationAsRead not implemented")
}
func (UnimplementedIMMsgServiceServer) BotMarkMaxMsgAsRead(context.Context, *BotMarkMaxMsgAsReadReq) (*BotMarkMaxMsgAsReadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BotMarkMaxMsgAsRead not implemented")
}
func (UnimplementedIMMsgServiceServer) SetConversationHasReadSeq(context.Context, *SetConversationHasReadSeqReq) (*SetConversationHasReadSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetConversationHasReadSeq not implemented")
}
func (UnimplementedIMMsgServiceServer) GetConversationsHasReadAndMaxSeq(context.Context, *GetConversationsHasReadAndMaxSeqReq) (*GetConversationsHasReadAndMaxSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConversationsHasReadAndMaxSeq not implemented")
}
func (UnimplementedIMMsgServiceServer) GetActiveUser(context.Context, *GetActiveUserReq) (*GetActiveUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveUser not implemented")
}
func (UnimplementedIMMsgServiceServer) GetActiveGroup(context.Context, *GetActiveGroupReq) (*GetActiveGroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveGroup not implemented")
}
func (UnimplementedIMMsgServiceServer) GetServerTime(context.Context, *GetServerTimeReq) (*GetServerTimeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServerTime not implemented")
}
func (UnimplementedIMMsgServiceServer) ClearMsg(context.Context, *ClearMsgReq) (*ClearMsgResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearMsg not implemented")
}
func (UnimplementedIMMsgServiceServer) DestructMsgs(context.Context, *DestructMsgsReq) (*DestructMsgsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestructMsgs not implemented")
}
func (UnimplementedIMMsgServiceServer) GetActiveConversation(context.Context, *GetActiveConversationReq) (*GetActiveConversationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveConversation not implemented")
}
func (UnimplementedIMMsgServiceServer) SetUserConversationMaxSeq(context.Context, *SetUserConversationMaxSeqReq) (*SetUserConversationMaxSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUserConversationMaxSeq not implemented")
}
func (UnimplementedIMMsgServiceServer) SetUserConversationMinSeq(context.Context, *SetUserConversationMinSeqReq) (*SetUserConversationMinSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUserConversationMinSeq not implemented")
}
func (UnimplementedIMMsgServiceServer) GetLastMessageSeqByTime(context.Context, *GetLastMessageSeqByTimeReq) (*GetLastMessageSeqByTimeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastMessageSeqByTime not implemented")
}
func (UnimplementedIMMsgServiceServer) GetLastMessage(context.Context, *GetLastMessageReq) (*GetLastMessageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastMessage not implemented")
}
func (UnimplementedIMMsgServiceServer) AddEmoji(context.Context, *AddEmojiReq) (*AddEmojiResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddEmoji not implemented")
}
func (UnimplementedIMMsgServiceServer) RevokeEmoji(context.Context, *RevokeEmojiReq) (*RevokeEmojiResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeEmoji not implemented")
}
func (UnimplementedIMMsgServiceServer) BotReadMsgsNotification(context.Context, *BotReadMsgsNotificationReq) (*BotReadMsgsNotificationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BotReadMsgsNotification not implemented")
}
func (UnimplementedIMMsgServiceServer) AIStreamMsgNotification(context.Context, *AIStreamNotificationReq) (*AIStreamNotificationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AIStreamMsgNotification not implemented")
}
func (UnimplementedIMMsgServiceServer) mustEmbedUnimplementedIMMsgServiceServer() {}
func (UnimplementedIMMsgServiceServer) testEmbeddedByValue()                      {}

// UnsafeIMMsgServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IMMsgServiceServer will
// result in compilation errors.
type UnsafeIMMsgServiceServer interface {
	mustEmbedUnimplementedIMMsgServiceServer()
}

func RegisterIMMsgServiceServer(s grpc.ServiceRegistrar, srv IMMsgServiceServer) {
	// If the following call pancis, it indicates UnimplementedIMMsgServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&IMMsgService_ServiceDesc, srv)
}

func _IMMsgService_GetMaxSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(sdkws.GetMaxSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetMaxSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetMaxSeq_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetMaxSeq(ctx, req.(*sdkws.GetMaxSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetMaxSeqs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMaxSeqsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetMaxSeqs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetMaxSeqs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetMaxSeqs(ctx, req.(*GetMaxSeqsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetHasReadSeqs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHasReadSeqsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetHasReadSeqs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetHasReadSeqs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetHasReadSeqs(ctx, req.(*GetHasReadSeqsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetMsgByConversationIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMsgByConversationIDsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetMsgByConversationIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetMsgByConversationIDs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetMsgByConversationIDs(ctx, req.(*GetMsgByConversationIDsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetConversationMaxSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConversationMaxSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetConversationMaxSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetConversationMaxSeq_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetConversationMaxSeq(ctx, req.(*GetConversationMaxSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_PullMessageBySeqs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(sdkws.PullMessageBySeqsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).PullMessageBySeqs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_PullMessageBySeqs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).PullMessageBySeqs(ctx, req.(*sdkws.PullMessageBySeqsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetSeqMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSeqMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetSeqMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetSeqMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetSeqMessage(ctx, req.(*GetSeqMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_SearchMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).SearchMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_SearchMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).SearchMessage(ctx, req.(*SearchMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_SendMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).SendMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_SendMsg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).SendMsg(ctx, req.(*SendMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_SendSimpleMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendSimpleMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).SendSimpleMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_SendSimpleMsg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).SendSimpleMsg(ctx, req.(*SendSimpleMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_SetUserConversationsMinSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserConversationsMinSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).SetUserConversationsMinSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_SetUserConversationsMinSeq_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).SetUserConversationsMinSeq(ctx, req.(*SetUserConversationsMinSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_ClearConversationsMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearConversationsMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).ClearConversationsMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_ClearConversationsMsg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).ClearConversationsMsg(ctx, req.(*ClearConversationsMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_UserClearAllMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserClearAllMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).UserClearAllMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_UserClearAllMsg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).UserClearAllMsg(ctx, req.(*UserClearAllMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_DeleteMsgs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMsgsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).DeleteMsgs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_DeleteMsgs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).DeleteMsgs(ctx, req.(*DeleteMsgsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_DeleteMsgPhysicalBySeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMsgPhysicalBySeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).DeleteMsgPhysicalBySeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_DeleteMsgPhysicalBySeq_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).DeleteMsgPhysicalBySeq(ctx, req.(*DeleteMsgPhysicalBySeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_DeleteMsgPhysical_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMsgPhysicalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).DeleteMsgPhysical(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_DeleteMsgPhysical_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).DeleteMsgPhysical(ctx, req.(*DeleteMsgPhysicalReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_SetSendMsgStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSendMsgStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).SetSendMsgStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_SetSendMsgStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).SetSendMsgStatus(ctx, req.(*SetSendMsgStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetSendMsgStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSendMsgStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetSendMsgStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetSendMsgStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetSendMsgStatus(ctx, req.(*GetSendMsgStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_RevokeMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).RevokeMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_RevokeMsg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).RevokeMsg(ctx, req.(*RevokeMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_MarkMsgsAsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkMsgsAsReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).MarkMsgsAsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_MarkMsgsAsRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).MarkMsgsAsRead(ctx, req.(*MarkMsgsAsReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_MarkConversationAsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkConversationAsReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).MarkConversationAsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_MarkConversationAsRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).MarkConversationAsRead(ctx, req.(*MarkConversationAsReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_RPCMarkConversationAsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCMarkConversationAsReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).RPCMarkConversationAsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_RPCMarkConversationAsRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).RPCMarkConversationAsRead(ctx, req.(*RPCMarkConversationAsReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_BotMarkMaxMsgAsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotMarkMaxMsgAsReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).BotMarkMaxMsgAsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_BotMarkMaxMsgAsRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).BotMarkMaxMsgAsRead(ctx, req.(*BotMarkMaxMsgAsReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_SetConversationHasReadSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetConversationHasReadSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).SetConversationHasReadSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_SetConversationHasReadSeq_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).SetConversationHasReadSeq(ctx, req.(*SetConversationHasReadSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetConversationsHasReadAndMaxSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConversationsHasReadAndMaxSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetConversationsHasReadAndMaxSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetConversationsHasReadAndMaxSeq_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetConversationsHasReadAndMaxSeq(ctx, req.(*GetConversationsHasReadAndMaxSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetActiveUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetActiveUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetActiveUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetActiveUser(ctx, req.(*GetActiveUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetActiveGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetActiveGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetActiveGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetActiveGroup(ctx, req.(*GetActiveGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetServerTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServerTimeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetServerTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetServerTime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetServerTime(ctx, req.(*GetServerTimeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_ClearMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).ClearMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_ClearMsg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).ClearMsg(ctx, req.(*ClearMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_DestructMsgs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestructMsgsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).DestructMsgs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_DestructMsgs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).DestructMsgs(ctx, req.(*DestructMsgsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetActiveConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveConversationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetActiveConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetActiveConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetActiveConversation(ctx, req.(*GetActiveConversationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_SetUserConversationMaxSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserConversationMaxSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).SetUserConversationMaxSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_SetUserConversationMaxSeq_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).SetUserConversationMaxSeq(ctx, req.(*SetUserConversationMaxSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_SetUserConversationMinSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserConversationMinSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).SetUserConversationMinSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_SetUserConversationMinSeq_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).SetUserConversationMinSeq(ctx, req.(*SetUserConversationMinSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetLastMessageSeqByTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLastMessageSeqByTimeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetLastMessageSeqByTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetLastMessageSeqByTime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetLastMessageSeqByTime(ctx, req.(*GetLastMessageSeqByTimeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_GetLastMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLastMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).GetLastMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_GetLastMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).GetLastMessage(ctx, req.(*GetLastMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_AddEmoji_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddEmojiReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).AddEmoji(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_AddEmoji_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).AddEmoji(ctx, req.(*AddEmojiReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_RevokeEmoji_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeEmojiReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).RevokeEmoji(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_RevokeEmoji_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).RevokeEmoji(ctx, req.(*RevokeEmojiReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_BotReadMsgsNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotReadMsgsNotificationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).BotReadMsgsNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_BotReadMsgsNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).BotReadMsgsNotification(ctx, req.(*BotReadMsgsNotificationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IMMsgService_AIStreamMsgNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIStreamNotificationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IMMsgServiceServer).AIStreamMsgNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IMMsgService_AIStreamMsgNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IMMsgServiceServer).AIStreamMsgNotification(ctx, req.(*AIStreamNotificationReq))
	}
	return interceptor(ctx, in, info, handler)
}

// IMMsgService_ServiceDesc is the grpc.ServiceDesc for IMMsgService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IMMsgService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "openim.msg.IMMsgService",
	HandlerType: (*IMMsgServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMaxSeq",
			Handler:    _IMMsgService_GetMaxSeq_Handler,
		},
		{
			MethodName: "GetMaxSeqs",
			Handler:    _IMMsgService_GetMaxSeqs_Handler,
		},
		{
			MethodName: "GetHasReadSeqs",
			Handler:    _IMMsgService_GetHasReadSeqs_Handler,
		},
		{
			MethodName: "GetMsgByConversationIDs",
			Handler:    _IMMsgService_GetMsgByConversationIDs_Handler,
		},
		{
			MethodName: "GetConversationMaxSeq",
			Handler:    _IMMsgService_GetConversationMaxSeq_Handler,
		},
		{
			MethodName: "PullMessageBySeqs",
			Handler:    _IMMsgService_PullMessageBySeqs_Handler,
		},
		{
			MethodName: "GetSeqMessage",
			Handler:    _IMMsgService_GetSeqMessage_Handler,
		},
		{
			MethodName: "SearchMessage",
			Handler:    _IMMsgService_SearchMessage_Handler,
		},
		{
			MethodName: "SendMsg",
			Handler:    _IMMsgService_SendMsg_Handler,
		},
		{
			MethodName: "SendSimpleMsg",
			Handler:    _IMMsgService_SendSimpleMsg_Handler,
		},
		{
			MethodName: "SetUserConversationsMinSeq",
			Handler:    _IMMsgService_SetUserConversationsMinSeq_Handler,
		},
		{
			MethodName: "ClearConversationsMsg",
			Handler:    _IMMsgService_ClearConversationsMsg_Handler,
		},
		{
			MethodName: "UserClearAllMsg",
			Handler:    _IMMsgService_UserClearAllMsg_Handler,
		},
		{
			MethodName: "DeleteMsgs",
			Handler:    _IMMsgService_DeleteMsgs_Handler,
		},
		{
			MethodName: "DeleteMsgPhysicalBySeq",
			Handler:    _IMMsgService_DeleteMsgPhysicalBySeq_Handler,
		},
		{
			MethodName: "DeleteMsgPhysical",
			Handler:    _IMMsgService_DeleteMsgPhysical_Handler,
		},
		{
			MethodName: "SetSendMsgStatus",
			Handler:    _IMMsgService_SetSendMsgStatus_Handler,
		},
		{
			MethodName: "GetSendMsgStatus",
			Handler:    _IMMsgService_GetSendMsgStatus_Handler,
		},
		{
			MethodName: "RevokeMsg",
			Handler:    _IMMsgService_RevokeMsg_Handler,
		},
		{
			MethodName: "MarkMsgsAsRead",
			Handler:    _IMMsgService_MarkMsgsAsRead_Handler,
		},
		{
			MethodName: "MarkConversationAsRead",
			Handler:    _IMMsgService_MarkConversationAsRead_Handler,
		},
		{
			MethodName: "RPCMarkConversationAsRead",
			Handler:    _IMMsgService_RPCMarkConversationAsRead_Handler,
		},
		{
			MethodName: "BotMarkMaxMsgAsRead",
			Handler:    _IMMsgService_BotMarkMaxMsgAsRead_Handler,
		},
		{
			MethodName: "SetConversationHasReadSeq",
			Handler:    _IMMsgService_SetConversationHasReadSeq_Handler,
		},
		{
			MethodName: "GetConversationsHasReadAndMaxSeq",
			Handler:    _IMMsgService_GetConversationsHasReadAndMaxSeq_Handler,
		},
		{
			MethodName: "GetActiveUser",
			Handler:    _IMMsgService_GetActiveUser_Handler,
		},
		{
			MethodName: "GetActiveGroup",
			Handler:    _IMMsgService_GetActiveGroup_Handler,
		},
		{
			MethodName: "GetServerTime",
			Handler:    _IMMsgService_GetServerTime_Handler,
		},
		{
			MethodName: "ClearMsg",
			Handler:    _IMMsgService_ClearMsg_Handler,
		},
		{
			MethodName: "DestructMsgs",
			Handler:    _IMMsgService_DestructMsgs_Handler,
		},
		{
			MethodName: "GetActiveConversation",
			Handler:    _IMMsgService_GetActiveConversation_Handler,
		},
		{
			MethodName: "SetUserConversationMaxSeq",
			Handler:    _IMMsgService_SetUserConversationMaxSeq_Handler,
		},
		{
			MethodName: "SetUserConversationMinSeq",
			Handler:    _IMMsgService_SetUserConversationMinSeq_Handler,
		},
		{
			MethodName: "GetLastMessageSeqByTime",
			Handler:    _IMMsgService_GetLastMessageSeqByTime_Handler,
		},
		{
			MethodName: "GetLastMessage",
			Handler:    _IMMsgService_GetLastMessage_Handler,
		},
		{
			MethodName: "AddEmoji",
			Handler:    _IMMsgService_AddEmoji_Handler,
		},
		{
			MethodName: "RevokeEmoji",
			Handler:    _IMMsgService_RevokeEmoji_Handler,
		},
		{
			MethodName: "BotReadMsgsNotification",
			Handler:    _IMMsgService_BotReadMsgsNotification_Handler,
		},
		{
			MethodName: "AIStreamMsgNotification",
			Handler:    _IMMsgService_AIStreamMsgNotification_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "msg/msg.proto",
}
